# 7/21

## TypeScript

公式ドキュメント: https://www.typescriptlang.org/docs/

## Parametersについて

・ [Parameters](https://www.typescriptlang.org/docs/handbook/utility-types.html#parameterstype)  
関数から引数の型を取り出すことができるUtility Typesのひとつ

```ts
function exampleFunction(x: number, y: string): void {}

type Params = Parameters<typeof exampleFunction>;
// [number, string]`
```

以下と同じ

```ts
type Parameters<T extends (...args: any) => any> = T extends (
  ...args: infer P
) => any
  ? P
  : never;
```

## OmitとExcludeの違いについて

オブジェクトから特定の型を除くのか、ユニオン型から除くのかの違い

- Omit<T,K>はオブジェクトTからプロパティKを除いた新しい型を作る
- Exclude<U, E>はユニオン型Uから特定の型Eを除いた新しい型を作る

# 7/22

## [Union型の分配](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

type-challengesの[Type Lookup](https://github.com/type-challenges/type-challenges/blob/main/questions/00062-medium-type-lookup/README.ja.md)について

これはNG  
U['type'] は 'cat' | 'dog'になる。

```ts
type LookUp<U extends { type: any }, T> = U["type"] extends T ? U : never;
```

これはOK  
Cat['type'] extends T と Dog['type'] extends Tで評価される（ユニオンが分配される）

```ts
type LookUp<U, T> = U extends { type: T } ? U : never;
```

"T extends ..." の場合にのみ分配が起こるらしい  
https://github.com/type-challenges/type-challenges/issues/75#issuecomment-774573867

## [テンプレートリテラル型](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

jsのテンプレートリテラルと同様に変数部分にリテラルを加えて、新しい型を返す。

```ts
type World = "world";

type Greeting = `hello ${World}`;
// type Greeting = "hello world"
```
