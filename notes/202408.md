# 8/1

## [Key Remappingのas](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

Mapped Typesのキーをasを使って上書きすることができる。

以下の例はasを使ってテンプレートリテラル型を利用している。

```ts
type Getters<Type> = {
  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property];
};

interface Person {
  name: string;
  age: number;
  location: string;
}

type LazyPerson = Getters<Person>;
// type LazyPerson = {
//     getName: () => string;
//     getAge: () => number;
//     getLocation: () => string;
// }
```

```ts
// kindを取り除く
type RemoveKindField<Type> = {
  [Property in keyof Type as Exclude<Property, "kind">]: Type[Property];
};

interface Circle {
  kind: "circle";
  radius: number;
}

type KindlessCircle = RemoveKindField<Circle>;
// type KindlessCircle = {
//     radius: number;
// }
```

## [インデックスシグネチャ以外を取り出す](https://github.com/type-challenges/type-challenges/blob/main/questions/01367-medium-remove-index-signature/README.md)

```ts
type RemoveIndexSignature<T, U = PropertyKey> = {
  [K in keyof T as U extends K ? never : K extends U ? K : never]: T[K];
};
```

- K in keyof T
  - Tの中のキーKを取り出す
- as U extends K
  - 前述のKを用いてキーを上書きする
  - U(symbol | string | number)がKサブタイプならKはsymbolかstringかnumberということになる。 つまりインデックスシグネチャと言えるのでneverを返す
  - U(symbol | string | number)がKのサブタイプではなければKはより具体的な型を持つということなのでインデックスシグネチャではない。
- K extends U ? K : never
  - KがUのサブタイプならKを返す
    - 例: "hoge" extends symbol | string | number
  - そうでなければneverを返す
