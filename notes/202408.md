# 8/1

## [Key Remappingのas](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

Mapped Typesのキーをasを使って上書きすることができる。

以下の例はasを使ってテンプレートリテラル型を利用している。

```ts
type Getters<Type> = {
  [Property in keyof Type as `get${Capitalize<string & Property>}`]: () => Type[Property];
};

interface Person {
  name: string;
  age: number;
  location: string;
}

type LazyPerson = Getters<Person>;
// type LazyPerson = {
//     getName: () => string;
//     getAge: () => number;
//     getLocation: () => string;
// }
```

```ts
// kindを取り除く
type RemoveKindField<Type> = {
  [Property in keyof Type as Exclude<Property, "kind">]: Type[Property];
};

interface Circle {
  kind: "circle";
  radius: number;
}

type KindlessCircle = RemoveKindField<Circle>;
// type KindlessCircle = {
//     radius: number;
// }
```

## [インデックスシグネチャ以外を取り出す](https://github.com/type-challenges/type-challenges/blob/main/questions/01367-medium-remove-index-signature/README.md)

```ts
type RemoveIndexSignature<T, U = PropertyKey> = {
  [K in keyof T as U extends K ? never : K extends U ? K : never]: T[K];
};
```

- K in keyof T
  - Tの中のキーKを取り出す
- as U extends K
  - 前述のKを用いてキーを上書きする
  - U(symbol | string | number)がKサブタイプならKはsymbolかstringかnumberということになる。 つまりインデックスシグネチャと言えるのでneverを返す
  - U(symbol | string | number)がKのサブタイプではなければKはより具体的な型を持つということなのでインデックスシグネチャではない。
- K extends U ? K : never
  - KがUのサブタイプならKを返す
    - 例: "hoge" extends symbol | string | number
  - そうでなければneverを返す

# 8/7

## Omit<T, never>について

Omit<T, K>はオブジェクト型TからキーKを除外して新しい型を返す。  
neverを除外する = 何も除外せずに元の型を返すということ。

コピーやマージをを実装するときによく使われるらしい

> In particular, usingOmit<T, never> is just a slick way of implementing the Copy or Merge types that are common in most of the other solutions.

https://github.com/type-challenges/type-challenges/issues/5395

# 8/8

## [Mapping Modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#mapping-modifiers)

プレフィックスに`-`や`+`をつけるとことで`readonly`や`?`を適用・解除できる。  
プレフィックスがない場合は`+`がついたものとして認識される。

```ts
// readonlyを外す場合
type CreateMutable<Type> = {
  -readonly [Property in keyof Type]: Type[Property];
};

// optinalを外す場合
type Concrete<Type> = {
  [Property in keyof Type]-?: Type[Property];
};
```

# 8/10

## オブジェクトのキーの型を強制する

https://github.com/type-challenges/type-challenges/issues/3282

```ts
type TupleToNestedObject<T, U> = T extends [infer F, ...infer S]
  ? {
      [P in F & string]: TupleToNestedObject<S, U>;
    }
  : U;
```

`F&string`はFとstringの交差型。こうすることでFがstring型であることを強制する。  
オブジェクトのキーにはstring | symbol | numberしか受け取れないので`&string`でstring型であることを明示している。`&string`がなければFの型が分からないことになる。

Fの型が分かればいいので`infer F extends PropertyKey`としても良い
